<%
  # Extract parameters with defaults
  form = local_assigns[:form]
  field = local_assigns[:field]
  options = local_assigns[:options] || []
  placeholder = local_assigns[:placeholder] || "Search or type..."
  help_text = local_assigns[:help_text]
  value = local_assigns[:value]
  required = local_assigns.fetch(:required, false)
  
  # Generate unique IDs based on form object name and field
  form_object_name = form.object_name.to_s.gsub(/[\[\]]/, '_').gsub(/__+/, '_')
  input_id = local_assigns[:input_id] || "#{form_object_name}_#{field}_input"
  hidden_input_id = "#{form_object_name}_#{field}_hidden"
  dropdown_id = local_assigns[:dropdown_id] || "#{form_object_name}_#{field}_dropdown"
  
  # Check if options have different keys and values (e.g., ID vs name)
  # If so, we need a hidden field for the actual value and display field for the text
  has_key_val_pairs = options.any? { |opt| opt.is_a?(Hash) && (opt[:key] || opt['key']) != (opt[:val] || opt[:value] || opt['val'] || opt['value']) }
  
  # Find the display value if we have an initial value
  display_value = nil
  if value.present? && has_key_val_pairs
    matching_option = options.find do |opt|
      if opt.is_a?(Hash)
        (opt[:key] || opt['key']).to_s == value.to_s
      else
        opt.to_s == value.to_s
      end
    end
    if matching_option.is_a?(Hash)
      display_value = matching_option[:val] || matching_option[:value] || matching_option['val'] || matching_option['value']
    else
      display_value = matching_option
    end
  end
  
  # Build input attributes for display field
  input_attrs = {
    class: "form-control",
    id: input_id,
    placeholder: placeholder,
    autocomplete: "off",
    type: "text"
  }
  input_attrs[:required] = true if required
  input_attrs[:value] = display_value || value if (display_value || value).present?
  
  # Merge any additional attributes passed in
  if local_assigns[:input_attrs].present?
    input_attrs.merge!(local_assigns[:input_attrs])
  end
%>

<div class="position-relative">
  <% if has_key_val_pairs %>
    <%= form.hidden_field field, id: hidden_input_id, value: value %>
    <%= text_field_tag nil, input_attrs[:value], input_attrs.except(:value).merge(id: input_id, name: nil, data: { hidden_field: hidden_input_id }) %>
  <% else %>
    <%= form.text_field field, input_attrs %>
  <% end %>
  
  <div class="dropdown-menu w-100" id="<%= dropdown_id %>" style="max-height: 300px; overflow-y: auto; display: none;">
    <% options.each do |option| %>
      <% 
        # Handle both hash and array formats
        if option.is_a?(Hash)
          option_key = option[:key] || option['key']
          option_val = option[:val] || option[:value] || option['val'] || option['value']
        else
          option_key = option
          option_val = option
        end
      %>
      <button type="button" class="dropdown-item searchable-option" data-value="<%= option_key %>" data-text="<%= option_val %>">
        <%= option_val %>
      </button>
    <% end %>
  </div>
</div>

<% if help_text.present? %>
  <small class="text-muted">
    <%= help_text %>
  </small>
<% end %>

<script>
  (function() {
    const inputId = '<%= input_id %>';
    const dropdownId = '<%= dropdown_id %>';
    
    function initSearchableDropdown() {
      const input = document.getElementById(inputId);
      const dropdown = document.getElementById(dropdownId);
      
      if (!input || !dropdown) return;
      
      const options = dropdown.querySelectorAll('.searchable-option');
      let isOpen = false;
      let mouseInDropdown = false;
      
      function showDropdown() {
        if (!isOpen) {
          dropdown.style.display = 'block';
          isOpen = true;
          filterOptions();
        }
      }
      
      function hideDropdown() {
        if (isOpen && !mouseInDropdown) {
          dropdown.style.display = 'none';
          isOpen = false;
        }
      }
      
      function filterOptions() {
        const searchTerm = input.value.toLowerCase().trim();
        
        options.forEach(option => {
          const optionText = option.textContent.toLowerCase();
          const optionValue = option.getAttribute('data-value').toLowerCase();
          const optionDisplayText = (option.getAttribute('data-text') || '').toLowerCase();
          
          if (optionText.includes(searchTerm) || optionValue.includes(searchTerm) || optionDisplayText.includes(searchTerm)) {
            option.style.display = '';
          } else {
            option.style.display = 'none';
          }
        });
      }
      
      // Show dropdown on focus
      input.addEventListener('focus', function() {
        showDropdown();
      });
      
      // Filter as user types
      input.addEventListener('input', function() {
        filterOptions();
        if (!isOpen) {
          showDropdown();
        }
        
        // If there's a hidden field and user clears the input, clear the hidden field too
        const hiddenFieldId = input.getAttribute('data-hidden-field');
        if (hiddenFieldId && input.value.trim() === '') {
          const hiddenField = document.getElementById(hiddenFieldId);
          if (hiddenField) {
            hiddenField.value = '';
          }
        }
      });
      
      // Handle option selection
      options.forEach(option => {
        option.addEventListener('click', function(e) {
          e.preventDefault();
          const optionValue = this.getAttribute('data-value');
          const optionText = this.getAttribute('data-text') || optionValue;
          
          // Check if there's a hidden field (for key/val pairs)
          const hiddenFieldId = input.getAttribute('data-hidden-field');
          if (hiddenFieldId) {
            const hiddenField = document.getElementById(hiddenFieldId);
            if (hiddenField) {
              hiddenField.value = optionValue;
              input.value = optionText;
            }
          } else {
            input.value = optionValue;
          }
          
          input.dispatchEvent(new Event('input', { bubbles: true }));
          
          // Force close dropdown when option is selected
          mouseInDropdown = false;
          dropdown.style.display = 'none';
          isOpen = false;
          input.focus();
        });
        
        option.addEventListener('mouseenter', function() {
          mouseInDropdown = true;
        });
        
        option.addEventListener('mouseleave', function() {
          mouseInDropdown = false;
        });
      });
      
      // Track mouse in dropdown
      dropdown.addEventListener('mouseenter', function() {
        mouseInDropdown = true;
      });
      
      dropdown.addEventListener('mouseleave', function() {
        mouseInDropdown = false;
      });
      
      // Hide on blur (but delay to allow clicks)
      input.addEventListener('blur', function() {
        setTimeout(() => {
          if (!mouseInDropdown) {
            hideDropdown();
          }
        }, 200);
      });
      
      // Close when clicking outside
      document.addEventListener('click', function(e) {
        if (!input.contains(e.target) && !dropdown.contains(e.target)) {
          hideDropdown();
        }
      });
      
      // Keyboard navigation
      input.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
          hideDropdown();
          input.blur();
        } else if (e.key === 'ArrowDown' && isOpen) {
          e.preventDefault();
          const visibleOptions = Array.from(options).filter(opt => opt.style.display !== 'none');
          if (visibleOptions.length > 0) {
            visibleOptions[0].focus();
          }
        }
      });
      
      // Initial filter if there's a value
      if (input.value) {
        filterOptions();
      }
    }
    
    // Initialize on DOM ready or Turbo load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initSearchableDropdown);
    } else {
      initSearchableDropdown();
    }
    
    // Re-initialize on Turbo navigation
    document.addEventListener('turbo:load', initSearchableDropdown);
  })();
</script>
